//С помощью пула воркеров написать программу, которая запускает 1000 горутин,
//каждая из которых увеличивает число на 1.
//Дождаться завершения всех горутин и убедиться, что при каждом запуске программы итоговое число равно 1000.
package main

import (
	"fmt"
)

func WorkerPool() {
	nGoroutine := 0 //Число запущенных горутин
	number := 0     //Число, которое будем увеличивать на 1 в каждой запущенной горутине
	pool := make(chan int, 1000)
	//Запускаем 1000 горутин
	for i := 1; i <= 1000; i++ {
		go send1ToChannel(pool, &number)
	}

	//пробовал запускать 1000 горутин в бесконечном цикле и выйти по условию, но у меня вылетает Goland
	//for {
	//	go send1ToChannel(pool, &number)
	//	if number == 1000 {
	//		break
	//	}
	//}

	//Читаем все значения из канала pool
	//Пробовал увеличить верхнюю границу до 1001, но при этом происходит аварийное завершение программы: все горутины спят
	for i := 1; i <= 1000; i++ {
		cn := <-pool
		nGoroutine += cn
	}
	fmt.Println("nGoroutine= ", nGoroutine, ", number= ", number)
	close(pool) //Или не нужно закрывать, т.к. все значения из канала считаны?
}

//send1ToChannel записывает в канал значение 1 и увеличивает принятое число на 1
func send1ToChannel(ch1 chan int, number *int)  {
	ch1 <- 1 //Запущена дна горутина - в канале записана одна единица, запущена тысяча горутин - в канале записана тысяча единиц
	*number++
}
func main() {
	WorkerPool()
}
